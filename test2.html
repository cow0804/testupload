<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>表格文字精準提取工具</title>
    <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>
    <style>
        /* 保持原有樣式，新增除錯面板 */
        .debug-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 保持原有介面結構 -->
        <div class="debug-panel">
            <h4>除錯資訊</h4>
            <button onclick="toggleDebug()">顯示原始識別數據</button>
            <pre id="rawData"></pre>
        </div>
    </div>

    <script>
        // 新增調試功能
        let debugMode = false;
        const rawDataDiv = document.getElementById('rawData');

        function toggleDebug() {
            debugMode = !debugMode;
            rawDataDiv.style.display = debugMode ? 'block' : 'none';
        }

        // 改進版 processImage 函數
        async function processImage(imageSource) {
            statusDiv.innerHTML = '正在進行影像預處理...';
            
            try {
                // 新增影像預處理步驟
                const preprocessedCanvas = await preprocessImage(imageSource);
                
                const worker = await Tesseract.createWorker({
                    logger: m => {
                        statusDiv.innerHTML += `<br>${m.status}`;
                        if(debugMode) rawDataDiv.innerHTML += JSON.stringify(m) + '\n';
                    }
                });

                // 強化語言設定
                await worker.loadLanguage('eng+osd'); // 新增文件方向檢測
                await worker.initialize('eng+osd');
                
                // 優化參數組合
                await worker.setParameters({
                    tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/:-\n',
                    tessedit_pageseg_mode: '6',  // 表格模式
                    tessedit_ocr_engine_mode: '3', // LSTM+傳統引擎混合
                    classify_enable_learning: '0',
                    classify_enable_adaptive_matcher: '0',
                    preserve_interword_spaces: '1',
                    textord_tabfind_show_blocks: debugMode ? '1' : '0'
                });

                const { data } = await worker.recognize(preprocessedCanvas);
                if(debugMode) rawDataDiv.innerHTML = `原始識別結果:\n${data.text}\n\nTSV數據:\n${data.tsv}`;
                
                // 改進表格解析演算法
                const tableData = parseTableData(data.tsv);
                renderTable(tableData);
                
                await worker.terminate();
                statusDiv.innerHTML = '解析完成！準確率：' + data.confidence.toFixed(1) + '%';
            } catch (err) {
                statusDiv.innerHTML = '處理失敗: ' + err.message;
            }
        }

        // 新增影像預處理函數
        async function preprocessImage(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 自動調整尺寸
            canvas.width = img.width * (img.height > 1000 ? 0.5 : 1);
            canvas.height = img.height * (img.height > 1000 ? 0.5 : 1);
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // 影像增強處理
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 簡易二值化處理
            for(let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                const threshold = avg > 128 ? 255 : 0;
                data[i] = data[i+1] = data[i+2] = threshold;
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // 改進版表格解析器
        function parseTableData(tsv) {
            return tsv.split('\n').map(line => {
                const cells = line.split('\t').filter(cell => {
                    return cell.trim() && !cell.match(/^[\W_]+$/); // 過濾純符號
                });
                return cells.map(cell => {
                    // 校正常見OCR錯誤
                    return cell.replace(/[Il1]/g, match => {
                        const replacements = {'I':'1', 'l':'1', '1':'I'};
                        return replacements[match] || match;
                    });
                });
            }).filter(row => row.length > 1);
        }

        // 表格渲染器強化
        function renderTable(data) {
            const headers = data[0].map((_, i) => `<th>欄位${i+1}</th>`).join('');
            const body = data.map(row => `
                <tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>
            `).join('');
            
            resultTable.innerHTML = `
                <thead><tr>${headers}</tr></thead>
                <tbody>${body}</tbody>
            `;
        }
    </script>
</body>
</html>
