<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>表格文字精準提取工具</title>
    <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>
    <style>
        /* 樣式保持不變 */
    </style>
</head>
<body>
    <div class="container">
        <h1>表格文字精準提取工具</h1>
        
        <div class="input-section">
            <div>
                <button onclick="startCamera()">開啟相機</button>
                <button onclick="capturePhoto()">拍攝照片</button>
            </div>
            <div>
                <input type="file" id="fileInput" accept="image/*">
            </div>
        </div>

        <div class="preview-area">
            <video id="videoPreview" autoplay></video>
            <img id="imagePreview" src="#" alt="預覽圖片" onload="handleImageLoad()">
        </div>

        <div id="processingStatus">等待操作...</div>
        <table class="result-table" id="resultTable"></table>

        <div class="debug-panel">
            <h4>除錯資訊</h4>
            <button onclick="toggleDebug()">顯示原始識別數據</button>
            <pre id="rawData"></pre>
        </div>
    </div>

    <script>
        let stream = null;
        const video = document.getElementById('videoPreview');
        const imagePreview = document.getElementById('imagePreview');
        const fileInput = document.getElementById('fileInput');
        const statusDiv = document.getElementById('processingStatus');
        const resultTable = document.getElementById('resultTable');
        const rawDataDiv = document.getElementById('rawData');
        let debugMode = false;

        // 啟動相機
        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                imagePreview.style.display = 'none';
                video.style.display = 'block';
                statusDiv.innerHTML = '相機已啟動，請拍攝照片';
            } catch (err) {
                alert('無法訪問相機: ' + err);
            }
        }

        // 拍攝照片
        function capturePhoto() {
            if (!stream) {
                alert('請先開啟相機！');
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            imagePreview.src = canvas.toDataURL('image/png');
            imagePreview.style.display = 'block';
            video.style.display = 'none';
        }

        // 處理文件上傳
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = 'block';
                    video.style.display = 'none';
                }
                reader.readAsDataURL(file);
            }
        });

        // 圖片載入完成後處理
        function handleImageLoad() {
            if (imagePreview.width === 0 || imagePreview.height === 0) {
                statusDiv.innerHTML = '錯誤：圖片尺寸為 0，請重新選擇圖片。';
                return;
            }
            processImage(imagePreview);
        }

        // 切換除錯模式
        function toggleDebug() {
            debugMode = !debugMode;
            rawDataDiv.style.display = debugMode ? 'block' : 'none';
        }

        // 影像處理核心邏輯
        async function processImage(imageSource) {
            statusDiv.innerHTML = '正在進行影像預處理...';
            resultTable.innerHTML = '';
            rawDataDiv.innerHTML = '';

            try {
                // 檢查圖片尺寸
                if (imageSource.width === 0 || imageSource.height === 0) {
                    throw new Error('圖片尺寸為 0，無法處理。');
                }

                // 影像預處理
                const preprocessedCanvas = await preprocessImage(imageSource);
                
                const worker = await Tesseract.createWorker({
                    logger: m => {
                        statusDiv.innerHTML += `<br>${m.status}`;
                        if(debugMode) rawDataDiv.innerHTML += JSON.stringify(m) + '\n';
                    }
                });

                // 強化語言設定
                await worker.loadLanguage('eng+osd');
                await worker.initialize('eng+osd');
                
                // 優化參數組合
                await worker.setParameters({
                    tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/:-\n',
                    tessedit_pageseg_mode: '6',
                    tessedit_ocr_engine_mode: '3',
                    classify_enable_learning: '0',
                    classify_enable_adaptive_matcher: '0',
                    preserve_interword_spaces: '1',
                    textord_tabfind_show_blocks: debugMode ? '1' : '0'
                });

                const { data } = await worker.recognize(preprocessedCanvas);
                if(debugMode) rawDataDiv.innerHTML = `原始識別結果:\n${data.text}\n\nTSV數據:\n${data.tsv}`;
                
                // 解析表格數據
                const tableData = parseTableData(data.tsv);
                renderTable(tableData);
                
                await worker.terminate();
                statusDiv.innerHTML = '解析完成！準確率：' + data.confidence.toFixed(1) + '%';
            } catch (err) {
                statusDiv.innerHTML = '處理失敗: ' + err.message;
            }
        }

        // 影像預處理
        async function preprocessImage(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 設置 Canvas 尺寸
            canvas.width = img.width;
            canvas.height = img.height;
            
            // 檢查圖片尺寸
            if (canvas.width === 0 || canvas.height === 0) {
                throw new Error('Canvas 尺寸為 0，無法處理。');
            }

            // 繪製圖片到 Canvas
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // 影像增強處理
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 簡易二值化處理
            for(let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                const threshold = avg > 128 ? 255 : 0;
                data[i] = data[i+1] = data[i+2] = threshold;
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // 解析表格數據
        function parseTableData(tsv) {
            return tsv.split('\n').map(line => {
                const cells = line.split('\t').filter(cell => {
                    return cell.trim() && !cell.match(/^[\W_]+$/);
                });
                return cells.map(cell => {
                    return cell.replace(/[Il1]/g, match => {
                        const replacements = {'I':'1', 'l':'1', '1':'I'};
                        return replacements[match] || match;
                    });
                });
            }).filter(row => row.length > 1);
        }

        // 渲染表格
        function renderTable(data) {
            const headers = data[0].map((_, i) => `<th>欄位${i+1}</th>`).join('');
            const body = data.map(row => `
                <tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>
            `).join('');
            
            resultTable.innerHTML = `
                <thead><tr>${headers}</tr></thead>
                <tbody>${body}</tbody>
            `;
        }
    </script>
</body>
</html>
